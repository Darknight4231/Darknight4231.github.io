<!DOCTYPE html>

<!-- Created on Feb 16, 2019 2:30:42 PM -->

<html lang="en">
  <head>
    <meta charset=utf-8 />
    <title>
      Enter a title here
    </title>
    <meta name="GENERATOR" content="Arachnophilia 5.5" />
    <meta name="FORMATTER" content="Arachnophilia 5.5" />
    <style>
       canvas { background: #eee;}
       body {
         
         background-color: rgb(10,200,255);
         font-family:  VL Gothic, arial;
         }
       
  </style>
  </head>
  
  <body>
    
    
<canvas id="myCanvas">
<p>This message is for those who can't have a canvas element running in their browser. Try a different browser to see what's on the page.</p>
</canvas>
<script>

//JEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//AAAAAAAAAAAAAAA
//this is what probably needs to change
window.addEventListener("click", arrowAngle);
window.addEventListener("keydown",keydown);

//Canvas is the screen made on the page, it's what JS is able to doodle on.
var canvas = document.getElementById("myCanvas");
var ctx = canvas.getContext("2d");

//this chooses the canvas "myCanvas" and makes it take up the same space as the window does. dunno about resizing updates.. ****Resizing does not work--whatever the window size is when loaded, is what you get.
var cramw = myCanvas.width = 1280;
var cramh = myCanvas.height = 600;

var arrowX = [];
var arrowY = [];
var Gravity = [];
var ArrowPower =[];
var mouseY = 0;

var C = 0;

var BX = [1200,1200,1200,1200];
var blocksY = [60, 100, 160, 340];


function collisionDetection() {
  
  for (var x=0; x<arrowX.length; x++){
    for (var y=0; y<arrowY.length; y++){
        //literally just make the arrows an object. this should solve a lot. maybe?
        //keeping as an array would allow to .pop or whatever as necessary, but it's still costly ain't it?
        //but is an object truly better in this circumstance?
        
        //I believe you can access an object and its properties in the same (well a better) way than you can in an array.
        //then it is settled. To look it up!
      }
    }
  }
  
  
  
  /* underneath is essentially the original... gross and doesn't work. But it is a point of reference.. somehow lol
    for(var c=0; c<arrowX; c++) {
        for(var r=0; r<arrowY; r++) {
            var b = arrowX[c][r];
  
            if() {
                
            }
  
        } 
    }*/
}


function arrowAngle(e){

 
 
   //mouseY needs to be converted to something divisible.
   //HOW DO I read the cursor Y position as an angle..?!?!?
   //that's what GravAngle is for.. would making mouseY into radians help?
  
 var mouseY = e.clientY;
  //this shows the radians
  //console.log((-(Math.atan((mouseY-400)/160))));
  
  GravAngle = ((-(Math.atan((mouseY-400)/160)*180/Math.PI)));
  GravRad = ((-(Math.atan((mouseY-400)/160))));
  //there are two points, to find the distance between the two, and find the two sides of the triangle it'd make. (x1,y1) (x2,y2)
  //it's easy, just do x1-x2 and y1-y2 or vice versa (x2-x1 and y2-y1)
  // Sin gives the angle from opposite to hypotenuse, we need using two legs of a right triangle. 
  //while we could find the distance using the X and Y method described above (distance = hypotenuse, use pythagorean theorem) we don't need the distance
  //we need the angle.
  //
  //this is to get an actual angle. it works wonderfully.  GravAngle = ((-(Math.atan((mouseY-400)/160)*180/Math.PI)));
  //a
  //tan=O/A  tangent = Opposite/Adjacent, the two sides we have available.
  //opposite is Y
  //adjacent is X
  
  mouseX = e.clientX;
  //find the distance between the two points, (60, 400) and (e.clientX, e.clientY)
  //then add that (with some kinda multiplier ofc to scale it down) to arrowX[C]
  pwr = (Math.pow( Math.pow(mouseX-60, 2) + Math.pow(mouseY-400, 2)  , 0.5));
  console.log(pwr/100);
 
  shot();
  //found within the shot(); function
  //arrowX.push (60);
  //arrowY.push (400);

  }

function shot (){
 
    arrowX.push (60);
    arrowY.push (400);
    ArrowPower.push(pwr/100);
    Gravity.push ((-0.9)+GravRad*4);
 }

function blocks(){
  
  for (var C=0; C<blocksY.length; C++){
    
    ctx.beginPath();
    ctx.fillStyle = `rgb(0,180,200)`;
    ctx.rect(BX[C], blocksY[C], 20,20);
    ctx.fill();
    ctx.closePath();
  }
  
 }

function background(){
    
    //this is the background itself
    ctx.beginPath();
    ctx.fillStyle = `rgba(50,50,50,0.4)`;
    ctx.rect( 0, 0, cramw, cramh);
    ctx.fill();
    ctx.closePath();
    
    //this is the spot to show where the arrow launches from (and is calculated at)
    ctx.beginPath();
    ctx.fillStyle = `rgb(255,0,0)`;
    ctx.rect(50, 390, 20, 20);
    ctx.fill();
    ctx.closePath();
    
    
  }
 
function draw(){
  
    ctx.clearRect(0,0,cramw,cramh);
    background();
    blocks();
    for ( var C=0; C < arrowX.length; C++){
    
    
    ctx.beginPath();
    ctx.fillStyle = `rgb(0,0,0)`;
    ctx.rect(arrowX[C], arrowY[C],18,3);
    ctx.fill();
    ctx.closePath();
    
  

    arrowY[C] =  arrowY[C]-Gravity[C];
    arrowX[C] = arrowX[C]+ArrowPower[C];
    
    Gravity[C] = Gravity[C]-0.02;
 
    }
    
collisionDetection();
  };

setInterval(draw,10);
draw();

    </script>    
    <p>
    This is a wonderful little project I'm working on. Hopefully one day you can actually do something in it. For now, though.. <br/><br/>
    It shoots (soon to be) arrows with care to showcase gravity, and (X,Y) values of clicks.
    FOR ME
    go here <a href="https://developer.mozilla.org/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript/Collision_detection">https://developer.mozilla.org/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript/Collision_detection</a>
    </p>
 
   <ul>
   <li>There is a red square that shows where the arrow is fired from
   <li>the blue line shows a level shooting field
   <li>clicking anywhere in the yellowish column shoots an arrow relative to mouse placement.</li>
   </ul>
  
   <ol>
   <li>Next up need to fix so the mouse is read from inside the canvas, not from the friggin window.. or is it reading from the client screen.. idk atm..
   <li>I want to make it so the arrows angle.. gonna need to review translations. UGH hahahaa
   <li>Gotta add more to the arrows.Arrow head, a tail/feather or whatev.  it'd be neat to have a trail on each/last fired arrow.
   <li><s>Add X values for sure, to change arrow speed and of course allow clicking anywhere inside the canvas (not the dang window itself!)</s>
   <li>These are NOT currently in order, and even if they were-- 'Order subject to change' ;D </li>
    </ol>
        
  
  </body>
</html>
